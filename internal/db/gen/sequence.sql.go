// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sequence.sql

package dao

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSequence = `-- name: CreateSequence :one
INSERT INTO sequences (sequence_name, open_tracking_enabled, click_tracking_enabled) 
VALUES ($1, $2, $3) 
RETURNING id, external_id, sequence_name, open_tracking_enabled, click_tracking_enabled, created, updated
`

type CreateSequenceParams struct {
	SequenceName         string `json:"sequence_name"`
	OpenTrackingEnabled  bool   `json:"open_tracking_enabled"`
	ClickTrackingEnabled bool   `json:"click_tracking_enabled"`
}

func (q *Queries) CreateSequence(ctx context.Context, arg CreateSequenceParams) (Sequence, error) {
	row := q.db.QueryRow(ctx, createSequence, arg.SequenceName, arg.OpenTrackingEnabled, arg.ClickTrackingEnabled)
	var i Sequence
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.SequenceName,
		&i.OpenTrackingEnabled,
		&i.ClickTrackingEnabled,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteSequence = `-- name: DeleteSequence :exec
DELETE FROM sequences 
WHERE external_id = $1
`

func (q *Queries) DeleteSequence(ctx context.Context, externalID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSequence, externalID)
	return err
}

const getSequenceById = `-- name: GetSequenceById :one
select 
    s.id, s.external_id, s.sequence_name, s.open_tracking_enabled, s.click_tracking_enabled, s.created, s.updated, 
	json_agg(row_to_json(t))::jsonb steps 
from sequences s
left join steps t on t.sequence_id = s.id
where s.external_id = $1
group by
	s.id,
	s.external_id,
	s.sequence_name,
	s.open_tracking_enabled,
	s.click_tracking_enabled,
	s.created,
	s.updated
`

type GetSequenceByIdRow struct {
	ID                   int32            `json:"id"`
	ExternalID           uuid.UUID        `json:"external_id"`
	SequenceName         string           `json:"sequence_name"`
	OpenTrackingEnabled  bool             `json:"open_tracking_enabled"`
	ClickTrackingEnabled bool             `json:"click_tracking_enabled"`
	Created              pgtype.Timestamp `json:"created"`
	Updated              pgtype.Timestamp `json:"updated"`
	Steps                []byte           `json:"steps"`
}

func (q *Queries) GetSequenceById(ctx context.Context, externalID uuid.UUID) (GetSequenceByIdRow, error) {
	row := q.db.QueryRow(ctx, getSequenceById, externalID)
	var i GetSequenceByIdRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.SequenceName,
		&i.OpenTrackingEnabled,
		&i.ClickTrackingEnabled,
		&i.Created,
		&i.Updated,
		&i.Steps,
	)
	return i, err
}

const getSequences = `-- name: GetSequences :many
select 
    s.id, s.external_id, s.sequence_name, s.open_tracking_enabled, s.click_tracking_enabled, s.created, s.updated, 
    json_agg(row_to_json(t))::jsonb steps 
from sequences s
left join steps t on t.sequence_id = s.id
group by
	s.id,
	s.external_id,
	s.sequence_name,
	s.open_tracking_enabled,
	s.click_tracking_enabled,
	s.created,
	s.updated
order by s.id
limit $1
offset $2
`

type GetSequencesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetSequencesRow struct {
	ID                   int32            `json:"id"`
	ExternalID           uuid.UUID        `json:"external_id"`
	SequenceName         string           `json:"sequence_name"`
	OpenTrackingEnabled  bool             `json:"open_tracking_enabled"`
	ClickTrackingEnabled bool             `json:"click_tracking_enabled"`
	Created              pgtype.Timestamp `json:"created"`
	Updated              pgtype.Timestamp `json:"updated"`
	Steps                []byte           `json:"steps"`
}

func (q *Queries) GetSequences(ctx context.Context, arg GetSequencesParams) ([]GetSequencesRow, error) {
	rows, err := q.db.Query(ctx, getSequences, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSequencesRow
	for rows.Next() {
		var i GetSequencesRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.SequenceName,
			&i.OpenTrackingEnabled,
			&i.ClickTrackingEnabled,
			&i.Created,
			&i.Updated,
			&i.Steps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSequence = `-- name: UpdateSequence :one
UPDATE sequences 
SET open_tracking_enabled = $2, click_tracking_enabled = $3 
WHERE id = $1 
RETURNING id, external_id, sequence_name, open_tracking_enabled, click_tracking_enabled, created, updated
`

type UpdateSequenceParams struct {
	ID                   int32 `json:"id"`
	OpenTrackingEnabled  bool  `json:"open_tracking_enabled"`
	ClickTrackingEnabled bool  `json:"click_tracking_enabled"`
}

func (q *Queries) UpdateSequence(ctx context.Context, arg UpdateSequenceParams) (Sequence, error) {
	row := q.db.QueryRow(ctx, updateSequence, arg.ID, arg.OpenTrackingEnabled, arg.ClickTrackingEnabled)
	var i Sequence
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.SequenceName,
		&i.OpenTrackingEnabled,
		&i.ClickTrackingEnabled,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
